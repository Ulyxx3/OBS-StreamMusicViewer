<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Now Playing - Apple Music</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="now-playing-widget" class="widget-container">
        <div id="content" class="content">
            <div class="album-art-container">
                <img id="album-art" src="" alt="Album Art" class="album-art">
                <div class="music-icon">ðŸŽµ</div>
            </div>
            <div class="track-info">
                <div id="title" class="track-title"><span class="scroll-text">Aucune lecture en cours</span></div>
                <div id="artist" class="track-artist"><span class="scroll-text"></span></div>
            </div>
        </div>
    </div>

    <script>
        class NowPlayingWidget {
            constructor() {
                this.currentSong = null;
                this.updateInterval = 1000; // 1 seconde
                this.autoReloadInterval = 10 * 60 * 1000; // 10 minutes
                this.jsonFile = 'current_song.json';

                // Ã‰lÃ©ments DOM
                this.elements = {
                    container: document.getElementById('now-playing-widget'),
                    content: document.getElementById('content'),
                    albumArt: document.getElementById('album-art'),
                    title: document.getElementById('title'),
                    artist: document.getElementById('artist')
                };

                this.init();
            }

            init() {
                console.log('ðŸŽµ Now Playing Widget initialisÃ©');
                this.startPolling();
            }

            async fetchCurrentSong() {
                try {
                    // Ajouter un timestamp pour Ã©viter le cache
                    const cacheBuster = `?t=${Date.now()}`;
                    const response = await fetch(this.jsonFile + cacheBuster);

                    if (!response.ok) {
                        throw new Error('Fichier JSON non trouvÃ©');
                    }

                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Erreur lors de la lecture du fichier JSON:', error);
                    return null;
                }
            }

            hasSongChanged(newSong) {
                if (!this.currentSong && newSong) return true;
                if (this.currentSong && !newSong) return true;
                if (!this.currentSong && !newSong) return false;

                return (
                    this.currentSong.title !== newSong.title ||
                    this.currentSong.artist !== newSong.artist
                );
            }

            async updateDisplay(songData) {
                // Si aucune chanson n'est en lecture
                if (!songData) {
                    await this.fadeOut();
                    this.setScrollText(this.elements.title, 'Aucune lecture en cours');
                    this.setScrollText(this.elements.artist, '');
                    this.elements.albumArt.style.display = 'none';
                    await this.fadeIn();
                    return;
                }

                // VÃ©rifier si la chanson a changÃ©
                if (this.hasSongChanged(songData)) {
                    console.log('ðŸŽµ Nouvelle chanson:', songData.title, '-', songData.artist);

                    // Transition fade out
                    await this.fadeOut();

                    // Mise Ã  jour du contenu
                    this.setScrollText(this.elements.title, songData.title);
                    this.setScrollText(this.elements.artist, songData.artist);

                    // Mise Ã  jour de la pochette d'album
                    if (songData.thumbnail) {
                        this.elements.albumArt.src = `data:image/jpeg;base64,${songData.thumbnail}`;
                        this.elements.albumArt.style.display = 'block';
                    } else {
                        this.elements.albumArt.style.display = 'none';
                    }

                    // Transition fade in
                    await this.fadeIn();

                    this.currentSong = songData;
                }
            }

            // DÃ©finit le texte et active le dÃ©filement si nÃ©cessaire
            setScrollText(container, text) {
                const span = container.querySelector('.scroll-text');

                // Annuler le cycle en cours
                if (span._scrollTimer) {
                    clearTimeout(span._scrollTimer);
                    span._scrollTimer = null;
                }
                span.style.transition = 'none';
                span.style.transform = 'translateX(0)';
                span.textContent = text;

                // Mesurer le dÃ©bordement aprÃ¨s rendu
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const overflow = span.scrollWidth - container.clientWidth;
                        if (overflow > 0) {
                            this.startScrollCycle(span, overflow);
                        }
                    });
                });
            }

            // Cycle : pause â†’ â† gauche â†’ pause â†’ droite â†’ â†’ recommence
            startScrollCycle(span, overflow) {
                const scrollDuration = Math.min(18000, Math.max(5000, (overflow / 50) * 1000));
                const pauseDuration = 3000; // 3s aux deux bouts

                const doCycle = () => {
                    // Phase 1 : pause au dÃ©but (position gauche)
                    span._scrollTimer = setTimeout(() => {
                        // Phase 2 : dÃ©filement vers la gauche
                        span.style.transition = `transform ${scrollDuration}ms linear`;
                        span.style.transform = `translateX(-${overflow}px)`;

                        // Phase 3 : pause Ã  la fin
                        span._scrollTimer = setTimeout(() => {
                            span._scrollTimer = setTimeout(() => {
                                // Phase 4 : retour vers la droite en douceur
                                span.style.transition = `transform ${scrollDuration}ms linear`;
                                span.style.transform = 'translateX(0)';

                                // AprÃ¨s le retour, recommencer le cycle
                                span._scrollTimer = setTimeout(doCycle, scrollDuration);
                            }, pauseDuration);
                        }, scrollDuration);
                    }, pauseDuration);
                };

                doCycle();
            }

            fadeOut() {
                return new Promise(resolve => {
                    this.elements.content.classList.remove('fade-in');
                    this.elements.content.classList.add('fade-out');
                    setTimeout(resolve, 300); // DurÃ©e de la transition
                });
            }

            fadeIn() {
                return new Promise(resolve => {
                    this.elements.content.classList.remove('fade-out');
                    this.elements.content.classList.add('fade-in');
                    setTimeout(resolve, 300); // DurÃ©e de la transition
                });
            }

            async poll() {
                const songData = await this.fetchCurrentSong();
                await this.updateDisplay(songData);
            }

            startPolling() {
                // Premier appel immÃ©diat
                this.poll();

                // Ensuite polling rÃ©gulier
                setInterval(() => {
                    this.poll();
                }, this.updateInterval);

                // Rechargement automatique toutes les 10 minutes pour Ã©viter les bugs d'affichage
                setTimeout(() => {
                    location.reload();
                }, this.autoReloadInterval);
            }
        }

        // Initialiser le widget au chargement de la page
        document.addEventListener('DOMContentLoaded', () => {
            new NowPlayingWidget();
        });
    </script>
</body>

</html>